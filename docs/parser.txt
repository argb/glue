主要用到的语法解析方法：
1、递归下降解析
2、表达式解析是用的递归下降的算符优先算法：TDOP
所用表达式解析算法的论文：https://tdop.github.io/

论文可能稍微有点不好理解，我尝试用另一个视角简单解释一下：

假设这里有一个复杂表达式：
1+2+3+4*5*6*7+add(9,10)-8+(-2)
那么每个运算符都有一个优先级，优先级之间的关系是 >,<,=, 这个算法的核心思想就是每个运算符都想争夺附近的operand来完成计算，争抢的规则就是
运算符的优先级。
那么我们提前给每种运算符设定好优先级，然后给定一个虚拟的初始运算符Epsilon(ε)
ε就有最低的优先级，可以规定为0，这个运算符并不存在，只是为了方便解释。
那么，表达式变成这样：
ε1+2+3+4*5*6*7+add(9,10)-8+(-2)
假设现在有一个令牌，获得令牌者可以进行一次计算（广义的计算，语法解析中主要就是构造节点），令牌会以此向下传递。
ε默认第一个持有令牌，
1、跟右边第一个操作数1结合，尝试计算：运算规则是先跟后面的运算符比较一下优先级，抢夺操作数，ε优先级小于+,ε计算失败，令牌传给+，
2、+重复上面的步骤，跟下一个运算+比较，优先级相等，抢夺成功，完成计算，计算结果为1+2，记为新的操作数n1，此时，表达式变为：
εn1+3+4*5*6*7+add(9,10)-8+(-2)
令牌归还给ε
3、ε获得令牌，继续尝试计算，重复1的步骤，又一次失败，令牌继续向下传递
因为ε具有最低的优先级，它的作用就是保证不停机，整个解析机器可以持续运行下去，它会屡败屡战、屡战屡败！直到最终成功，因为就剩下他自己了，可怜啊!
......

循环、递归的进行上面的步骤，最终ε收尾，完成最后的计算，得到结果N，N可能构成如下
N=n8+n7
n8=n6-n5
n7=n3/n2
n2=6
........
最终，N展开后可以构成一棵树，而这棵树就是我们需要的AST，抽象语法树。
至此，对表达式的语法分析过程就完成了。
这种解析方式可以省去了大量表达式相关的BNF范式语法规则。
这样使得整个语言的语法规则得到简化：
BNF就主要只剩下各种语句的描述，比如
赋值语句
<赋值语句> ::= let <expression> = <expression>
等等。。。，
