这里我想先提一个问题：信息是如何被传递的？
因为接下来我们的所作的一切都是为了一个目标：信息传递。

我们用高级语言描述一个需求，期望得到某个结果，达成某个目标，然后我们把高级语言喂给机器，期望最终机器的输出可以达成我们所期望的目标。
这中间发生了什么？为什么这样就可以达成目标？

这里我想给信息下一个定义，用三元组表示它：
信息=【原始数据+结构+解析规则】

这里最需要理解的是"结构"，因为"原始数据"是很直观的，基本上就是我们看到的样子，或者我们直觉感受到的样子，
"解析规则"其实是隐含并强制的，因为我们试图从一份数据中提取信息的时候，总是在"按照某种规则"去提取，即使你没意识到自己在使用某种规则，
但你客观上也一定在使用某种规则。

而"结构"是最抽象和容易被忽视的。

当我们把一种数据变换成另一种形式时，原始数据的一部分信息其实被编码到了新数据的"结构"上，也就是说结构本身就是信息的一部分。
然后我们再设计某种规则，基于这种规则去访问这个结构，就可以还原原始数据的信息。
而这一切就是我们之后要做的事情。

总之，记住一点：信息会被编码进结构，结构就是信息的一部分。
这是信息可以被以不同的形式传递的根本原因，而能不能"找到一种合理的方式去使用这个结构"最终决定了我们能否提取出正确的信息，
也就是结构被转换之前的信息。

高级语言-->AST-->ByteCode-->VM
上面的每一个步骤代表了一种结构变换，通过这种结构变换完成了一次信息的编码和传递。

这里我简单说一下VM是如果按照我们前面说的逻辑还原信息的。
首先，对于VM来说，初始数据是ByteCode，这是一种字节码，表面上看起来是一堆毫无意义的二进制数据，重点来了：
虚拟机具备某种结构，这种结构基于某种被设定好的规则，使得虚拟机的各个组件（结构的构成成分）互相配合去执行一些动作，最终完成从ByteCode提取信息
的任务。看到了吗？这里提到虚拟机具备某种结构，也就是说虚拟机本身就编码了ByteCode的一部分信息，然后又以某种规则是使用这个结构，也就是对应
某种提取信息的方式，或者说解析规则。完全符合我们前面讲述的信息传递的规则。
而这就是为什么VM可以还原高级语言所表达的原始信息。
VM的结构并不是固定的，重要的是"某种VM结构+对应的解析规则"可以有合理配合。在看一下开头对信息的形式化定义：
信息=【原始数据+结构+解析规则】，如果我们假设：
f(x,y,z) =x + y + z,
bytecode = x, 这个值如果固定的话， 只要保证y+z的值是某个固定值，就可以保证最终结果的正确，而y和z可以各自独立变化。
也就是说，VM可以是不同的结构+不同的使用方式，都有可能达成目标。
这个项目中我们用的VM是一种Stack Machine，顾名思义，是一种基于"栈"概念来执行指令的机器。

如果抛开中间过程，只看两端的话就是：高级语言-->VM
我们把VM等价成真是的硬件机器的话，从语言使用者的角度就是用高级语言写了段程序，VM处理之后给了我们期望的结果，之所以符合预期，就是因为信息
被准确的传递给后者，后者准确还原了前者的信息，给我们的直观感受就是：符合预期。

理解这一点的意义在于让我们知道这东西到底在干啥，可以让我们从"上帝视角"这个很高的高度去看清事情的全貌，而不是总是深陷某个环节，
一直处于"不识庐山真面目"的状态。
下面开始这段奇妙的旅程吧！