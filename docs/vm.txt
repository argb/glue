VM是一个栈结构的虚拟机，一台Stack Machine

VM相关数据结构
1、全局常量表（这里的常量是指编译时确定的一个值）
用于编译时确定的各种字面量值：数字、字符串、函数定义、数组定义、hash定义
内置函数池，存储所有内置函数的定义，直接把object.builtin里面的内容加载到内存

2、局部变量
在运行时遇到函数调用指令，会在数据栈上划定一块区域，
3、函数实参
跟局部变量类似
3、自由变量

4、栈帧
随着函数调用创建，函数返回后销毁
栈帧上绑定这改函数相关的指令、相对ip值、数据栈sp的基准地址，也就是调用返回后要回到的地方

5、数据栈
机器的舞台，所有指令执行的场所，所有数据暂存的场所

6、指令集

7、闭包的运行时构建
闭包的机制的完成涉及到编译器和VM的合作，编译器根据静态作用域生成相关指令，如：
在函数作用域内确定闭包变量，生成OpFree指令，用于将变量值加载到stack。
但是这些还不够，编译器还会生成相应指令，让VM在生成闭包前，把包含自由变量数据的对象加载到stack，这些先于函数对象加载，紧邻函数对象，也就是在
数据栈顶指针sp之下的numFree的几个槽位。
OpClosure指令会加载函数对象，并从栈上读取这几个自由变量的数据，跟函数对象一块打包成一个Closure对象，然后压栈，供其他指令使用。
后续如果有OpCall指令执行，会加载closure对象，然后直接使用里面的对应变量。
函数对应的自由变量就会永远跟随函数对象，不会受到stack变化的影响，当然也不会被销毁。
VM只是做了一个打包处理，实际上是编译器完成了自由变量的转移。
编译器在分析函数定义的时候，会确定里面应用了哪些自由变量，将其信息暂存在一个对应作用域下的自由变量符号表，然后在父级作用域遍历这个符号表，生成
相应指令。VM只是执行这些指令，加载数据，然后做一个打包处理，也就最终完成了enclose those free variables, then got an object called
Closure.
That's it and that's why it's called Closure.
Because it indeed enclosed sth.
