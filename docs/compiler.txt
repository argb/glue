一、所有不变量都在constants表中
所谓不变量在这里是指各种字面量，因为语言层面暂时没有给出常量的语法定义

二、所有变量都在对应作用域的符号表中symbolTable, 既所有左值出现时，都是在符号表中进行定义。
所谓左值就是赋值符号左边的值，所有右值都会被求解或者生成对应的求解指令，由vm完成实际求解

变量取值指令的操作数跟变量在对应层级符号表中的位置一致，也就是说是个偏移量。

let a=10;
a;

会有以下数据结构
constants: [10]
symbolTable: [a]
对应字节码指令：
OpConstant 0  // 把10取出，压栈
OpSetGlobal 0 // 0对应a的索引， 10出栈，然后存入globals这个全局内存中
OpGetGlobal 0 // 从globals中取出10, 压栈
OpPop         // 10 出栈，此时程序运行结束，栈也被清空了

三、全局变量的信息记录在全局符号表，局部变量的信息记录在局部作用域对应的符号表
实际上全局变量可以看做作用域链的最外层，也就对应符号表链的最外层，符号表链是个链表结构的栈
每次局部变量定义在最内层符号表，最内层可以看做栈顶，跟函数定义层次对应，但是变量可以在不但可以在当前符号表查询，还可以沿着
整个作用域栈遍历查询。
不在当前作用域对应符号表上，而存在与外层符号表的的变量定义，如果不是全局的（最外层那个），就认为是自由变量。
持有自由变量的函数，在执行的时候会形成闭包。

4、符号表
符号表记录存储了符号，每个符号记录了某个变量的信息，包括：变量名字，所属的作用域类型，该符号在符号表中的位置
另外，符号表中还有个计数器，每定义一个符号就加一，可以通过此值直接获取某个符号表的符号总数。
注意，符号表并不会记录变量的实际值，只是对变量的一些描述信息。
这些信息可以指导我们的编译器如何生成指令，比如：这条指令应该由什么操作符和操作数构成。

5、函数调用
函数名相当于右值，会对其求值，求值结果是这个函数名绑定的函数字面量定义，次对象会被压栈，然后执行调用指令OpCall, 此指令会设置很多VM的运行时环境，
具体参考VM相关的介绍。
总结一下就是，编译器检测到函数调用节点时，会生成最少两条指令：
第一条：根据函数名加载函数字面量所对应的对象
然后是可能存在的其他指令，比如实参，实参如果是个复杂表达式的话，这里可能会有很多指令生成
最后一条是OpCall,此指令执行完成之后，VM环境被修改，机器会进入函数的语句块执行函数对应的语句。
最后返回，恢复函数调用前的VM运行时状态，包括,sp、ip、fp，fp就是frame pointer，ip是frame上的一个属性，也就是说fp改变的话ip一定改变。
return指令会将前面"第一条"加载的函数对象pop出栈，将函数运行结果压栈。
至此整个函数调用执行完毕。