let m=100;
let f1=fn(){
    let a=10;
    let f2=fn(x){
        let b=m;
        let f3=fn(){
            return a+b;
        }
        return f3();
    }
    return f2(100);
}

f1();

解析f3内部：

a,b原符号直接 存到f3的符号表中的自由变量表，索引也不动。
并且修改a,b的作用域为freescope，然后存在f3的当前作用域，索引为自由变量符号表的索引
以上过程产生的所有指令在f3的作用域内，关联到f3的栈帧。

暂存f3的自由变量符号表，退出f3的作用域，回退到f2的作用域，从现在开始生成的指令属于f2，位于f2的栈帧，遍历这个暂存的自由变量表，
里面都是原始符号，把相应的数据加载到栈上，此时只是生成加载指令。



解析f2，从外部解析f3

